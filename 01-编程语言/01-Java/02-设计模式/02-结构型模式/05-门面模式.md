## **门面模式 Facade**

### **系统间耦合的复杂度**

![](https://raw.githubusercontent.com/jiangshuangjun/studynote/master/04-%E8%B5%84%E6%BA%90/01-%E5%9B%BE%E7%89%87/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F_%E5%9C%BA%E6%99%AF%E5%BC%95%E5%AF%BC%E5%9B%BE.jpg)

### **动机(Motivation)**

- 上述 A 方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合会面临跟多变化的挑战。
- 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

### **模式定义**

为子系统中的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF

### **结构(Structure)**

![](https://raw.githubusercontent.com/jiangshuangjun/studynote/master/04-%E8%B5%84%E6%BA%90/01-%E5%9B%BE%E7%89%87/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpg)

### **要点总结**

- 从客户程序的角度来说，Facade 模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果——内部子系统的任何变化不会影响到 Facade 接口的变化。
- Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade 很多时候更是一种架构设计模式。
- Facade 设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade 模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。

### **代码实现**

TODO

